"""模块"""
# 把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块
# 模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py，模块可以被别的程序引入，以使用该模块中的函数等功能，这也是使用python标准库的方法
# 下面是使用python标准库中模块的实例：
import sys

print('命令行参数如下：')
for i in sys.argv:
    print(i)

print('\n\npython 路径为：', sys.path, '\n')


# import sys 引入python标准库中的sys.py模块，这是引入某一模块的方法
# sys.argv是一个包含命令行参数的列表
# sys.path包含了一个python解析器自动查找所需模块的路径的列表

# import语句
# 想要使用python源文件，只需在另一个源文件里执行import语句，语法如下：
# import module1,module2...
# 当解释器遇到import语句，如果模块在当前的搜索路径就会被导入
# 搜索路径是一个解释器会先进行搜索的所有目录的列表，如果想要导入模块support,需要把命令放在脚本的顶端：
def print_func(par):
    print("hello:", par)
    return


# 导入模块
import support

# 现在可以调用模块里包含的函数了
support.print_func("run")

# 一个模块只会被导入一次，不管你执行多少次import，这样可以防止导入模块被一遍又一遍的执行
# 当我们使用import语句的时候，python解释器是怎样找到对应的文件的呢？
# 这就涉及到python的搜索路径，搜索路径是由一系列目录名组成的，python解析器就依次从这些目录中去寻找所引入的模块
# 这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径
# 搜索路径是在python编译或安装的时候确定的，安装新的库应该也会修改，搜索路径被存储在sys模块中的path变量，做一个简单的实验：
import sys

sys.path


# sys.path输出是一个列表，其中第一项是空串""，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚的看出是哪个目录），
# 亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）
# 因此若像我一样在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉
# 了解了搜索路径的概念，就可以在脚本中修改sys.path来引入一些不在搜索路径中的模块
# 现在，在解释器的当前目录或者sys.path中的一个目录里面来创建一个fibo.py的文件，代码如下：
def fib(n):  # 定义到n的斐波那契数列
    a, b = 0, 1
    while b < n:
        print(b, end="")
        a, b = b, a + b
    print()


def fib2(n):  # 返回到n的斐波那契数列
    result = []
    a, b = 0, 1
    while b < n:
        result.append(b)
        a, b = b, a + b
    return result


# from ... import 语句
# python的from语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：
# from modname import name1,name2...

# from ... import * 语句
# 把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需要使用如下声明：
# from modname import *

# 深入模块
# 模块除了方法定义，还可以包括可执行的代码，这些代码一般用来初始化这个模块，这些代码只有在第一次被导入时才会被执行
# 每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用
# 所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞花
# 另一个方面，当前确定知道你在做什么的话，你也可以通过modname.itemname这样的表示法来访问模块内的函数
# 模块是可以导入其他模块的，在一个模块（或者脚本，或者其他地方）的最前面使用import来导入一个模块，当然这只是一个惯例，而不是强制的
# 被导入的模块的名称将放入当前操作的模块的符号表中
# 还有一种导入的方法，可以使用import直接把模块内（函数，变量的）名称导入到当前操作模块，比如：
from fibo import fib, fib2
fib(500)
# 这种导入的方法不会把被导入的模块的名称放在当前的字符表中

# __name__属性
# 一个模块被另一个程序第一次引入时，其主程序将运行，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行
if __name__ == '__main__':
    print('程序自身在运行')
else:
    print('我来自另一模块')
# 说明：每个模块都有一个__name__属性，当其值是'__main'时，表明该模块自身在运行，否则是被引入
# 说明：__name__与__main__底下是双下划线

# dir()函数
# 内置的函数dir()可以找到模块内定义的所有名称，以一个字符串列表的形式返回：
import fibo, sys
dir(fibo)
# 如果没有给定参数，那么dir()函数会罗列出当前定义的所有名称
import fibo
fib = fibo.fib

# 标准模块
# python本身带有一些标准的模块库，在python库参考文档中将介绍到
# 有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题
# 这些组件会根据不同的操作系统进行不同形式的配置，比如winreg这个模块就只会提供为windows系统
# 应该注意到这有一个特别的模块sys，它内置在每一个python解析器中，变量sys.ps1和sys.ps2定义了主提示符和副提示符所对应的字符串：

# 包
# 包是一种管理python模块命名空间的形式，采用"点模块名称"
# 比如一个模块的名称是A.B，那么他表示一个包A中的子模块B
# 就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况
# 这样不同的作者都可以提供NumPy模块，或者是python图形库
